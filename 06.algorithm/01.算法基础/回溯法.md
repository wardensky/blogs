# 回溯法

## 概念
回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。

回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。

许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。

## 基本思想

在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。

若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。

而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。

## 用回溯法解题的一般步骤：

（1）针对所给问题，确定问题的解空间：
  首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。

（2）确定结点的扩展搜索规则

（3）以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。

## 算法框架

### 问题框架

设问题的解是一个n维向量(a1,a2,………,an),约束条件是ai(i=1,2,3,…..,n)之间满足某种条件，记为f(ai)。

### 非递归回溯框架
```

   int a[n],i;
   初始化数组a[];
   i = 1;
   while (i>0(有路可走)   and  (未达到目标))  // 还未回溯到头
   {
       if(i > n)                                              // 搜索到叶结点
       {
             搜索到一个解，输出；
       }
       else                                                   // 处理第i个元素
       {
             a[i]第一个可能的值；
             while(a[i]在不满足约束条件且在搜索空间内)
             {
                 a[i]下一个可能的值；
             }
             if(a[i]在搜索空间内)
            {
                 标识占用的资源；
                 i = i+1;                              // 扩展下一个结点
            }
            else
           {
                 清理所占的状态空间；            // 回溯
                 i = i –1;
            }
   }
```
### 递归的算法框架

回溯法是对解空间的深度优先搜索，在一般情况下使用递归函数来实现回溯法比较简单，其中i为搜索的深度，框架如下：

```
   int a[n];

   try(int i)
   {
       if(i>n)
          输出结果;
        else
       {
          for(j = 下界; j <= 上界; j=j+1)  // 枚举i所有可能的路径
          {
              if(fun(j))                 // 满足限界函数和约束条件
                {
                   a[i] = j;
                 ...                         // 其他操作
                   try(i+1);
                 回溯前的清理工作（如a[i]置空值等）;
                 }
            }
        }
   }
```  


## 八皇后问题描述：

八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例：在8X8格的国际象棋棋盘上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。

## 八皇后问题求解：

采用回溯算法，即从第一行开始，依次探查可以放置皇后的位置，若找到，则放置皇后，开始探查下一行；若该行没有位置可以放置皇后，则回溯至上一行，清除该行放置皇后的信息，从该行原本放置皇后的下一个位置开始探查可以放置皇后的位置。求所有解时，每找到一组解，就清除这一组解最后一个皇后的位置信息，开始探查该行另外一个可以放置皇后的位置，依次回溯求解。

## 代码实现

## 输出

## 参考

- [八皇后问题][1]
- [五大常用算法之四：回溯法][2]

[1]:https://www.jianshu.com/p/1ad1026c5a8b
[2]:http://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741376.html
