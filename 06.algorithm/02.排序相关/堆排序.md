# 堆排序

## 堆的定义

请[参考][1]

## 算法和思路

### 主要思想

堆排序的基本思想是：

>将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了


### 步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。

#### 1. 假设给定无序序列结构如下

![][2]

#### 2. 此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。

![][3]

#### 3.找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换。

![][4]

#### 4.这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6。

![][5]

此时，我们就将一个无需序列构造成了一个大顶堆。


### 步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。



## 代码实现

## 总结

堆排序是一种选择排序，整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。其中构建初始堆经推导复杂度为O(n)，在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质，[log2(n-1),log2(n-2)...1]逐步递减，近似为nlogn。所以堆排序时间复杂度一般认为就是O(nlogn)级。


## 参考


- [图解排序算法(三)之堆排序][4]



[1]:https://github.com/wardensky/blogs/blob/master/06.algorithm/04.%E6%A0%91%E7%9B%B8%E5%85%B3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86.md
[2]:../images/堆排序-1.png
[3]:../images/堆排序-2.png
[4]:../images/堆排序-3.png
[5]:../images/堆排序-4.png
[6]:../images/堆排序-5.png
[7]:../images/堆排序-6.png
[8]:../images/堆排序-7.png
[9]:../images/堆排序-8.png
