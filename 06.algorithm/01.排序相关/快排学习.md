# 快排学习


快速排序（Quicksort）是对冒泡排序的一种改进。
快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。


## 算法介绍

设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。
一趟快速排序的算法是：
1. 设置两个变量i、j，排序开始的时候：i=0，j=N-1；
2. 以第一个数组元素作为关键数据，赋值给key，即key=A[0]；
3. 从j开始向前搜索，即由后开始向前搜索(j--)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；
4. 从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；
5. 重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。

## 排序演示

假设用户输入了如下数组：
```
57, 68, 59, 52, 72, 28, 96, 33, 24
```

第一次交换，从后往前找，找第一个比57小的，交换位置。结果如下：
```
24, 68, 59, 52, 72, 28, 96, 33, 57
```

第二次交换，从前往后找，找第一个比57大的，交换位置。结果如下：
```
24, 57, 59, 52, 72, 28, 96, 33, 68
```

第三次交换，从后往前找，找第一个比57小的，交换位置。结果如下：

```
24, 33, 59, 52, 72, 28, 96, 57, 68
```

第四次交换，从前往后找，找第一个比57大的，交换位置。结果如下：
```
24, 33, 57, 52, 72, 28, 96, 59, 68
```



第五次交换，从后往前找，找第一个比57小的，交换位置。结果如下：

```
24, 33, 28, 52, 72, 57, 96, 59, 68
```

第六次交换，从前往后找，找第一个比57大的，交换位置。结果如下：
```
24, 33, 28, 52, 57, 72, 96, 59, 68
```

到此位置，再也找不到57前面比57大的，57后面比57小的。下面分成两个部分继续递归

```
24, 33, 28, 52
72, 96, 59, 68
```




## Java代码示例

网上查的代码如下：
```
static void quicksort(int n[], int left, int right) {
  int dp;
  if (left < right) {
    dp = partition(n, left, right);
    quicksort(n, left, dp - 1);
    quicksort(n, dp + 1, right);
  }
}

static int partition(int n[], int left, int right) {
  int pivot = n[left];
  while (left < right) {
    while (left < right && n[right] >= pivot)
      right--;
    if (left < right)
      n[left++] = n[right];
    while (left < right && n[left] <= pivot)
      left++;
    if (left < right)
      n[right--] = n[left];
  }
  n[left] = pivot;
  return left;
}
```


我实现的版本如下：

```
static void qs(int n[], int leftPoint, int rightPoint) {
  if (leftPoint == rightPoint) {
    return;
  }
  int pos = p(n, leftPoint, rightPoint);
  System.out.println("pos = " + pos);
  if (pos > 2) {
    qs(n, leftPoint, pos - 1);
  }
  if (pos + 1 < rightPoint) {
    qs(n, pos + 1, rightPoint);
  }
}

static int p(int n[], int leftPoint, int rightPoint) {

  if (leftPoint >= rightPoint) {
    return leftPoint;
  }
  int current = n[leftPoint];
  while (leftPoint < rightPoint) {

    System.out.println("rightPoint = " + rightPoint);
    System.out.println("leftPoint = " + leftPoint);

    while (leftPoint < rightPoint) {

      int rightValue = n[rightPoint];
      if (current > rightValue) {
        System.out.println("右边小交换");
        n[leftPoint] = rightValue;
        n[rightPoint] = current;
        printArray(n);

        break;
      }
      rightPoint--;

    }
    while (leftPoint < rightPoint) {

      int leftValue = n[leftPoint];
      if (current < leftValue) {
        System.out.println("左边大交换");
        n[leftPoint] = current;
        n[rightPoint] = leftValue;
        printArray(n);

        break;
      }
      leftPoint++;
    }

  }
  System.out.println("跳出 = " + leftPoint);
  return leftPoint;
}

```

## 参考

- [快速排序算法](https://baike.baidu.com/item/快速排序算法)
- [快速排序算法Java实现](http://www.cnblogs.com/vanezkw/archive/2012/06/21/2557685.html)
